rm(list=ls(all=TRUE))

setwd("J:/Analytics/Batch_25/CSE7202c/Day03")

data<-read.csv("CustomerData_Classification.csv",header=T)
str(data)
summary(data)

# Preprocessing 

# remove CustomerID column
data = data[,-1]

# convert City attribute as factor
data$City = as.factor(as.character(data$City))

# Convert taget attribute as factor
data$Churned<-as.factor(as.character(data$Churned))

dataForModel = data

#Split the data into train and test data sets
rows=seq(1,nrow(dataForModel),1)
set.seed(123)
trainRows=sample(rows,(70*nrow(dataForModel))/100)
train = dataForModel[trainRows,] 
test = dataForModel[-trainRows,]

# Build Logistic regression and interpret the results
LogReg <- glm(Churned ~ ., data=train, family=binomial)
summary(LogReg)

# train results
prob<-predict(LogReg, type="response")
pred_class <- ifelse(prob> 0.5, 1, 0)
table(train$Churned,pred_class)

# Test results 
fitted.results <- predict(LogReg,test,type='response')
fitted.class <- ifelse(fitted.results > 0.5,1,0)
table(test$Churned,fitted.class)



#As a last step, we are going to plot the ROC curve and calculate the AUC 
#(area under the curve) which are typical performance measurements 
#for a binary classifier.
#The ROC (Receiver Operating Characteristic curve) is a curve generated by plotting the true positive rate (TPR = sensitivity) against
# the false positive rate (FPR= specificity) at various threshold settings while the AUC is
# the area under the ROC curve. As a rule of thumb, a model with good 
#predictive ability should have an AUC closer to 1 (1 is ideal) than to 0.5.


library(ROCR)
p <- predict(LogReg,test, type="response")
pr <- prediction(p, test$Churned)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf,colorize = TRUE, print.cutoffs.at=seq(0,1,by=0.1), text.adj=c(-0.2,1.7))

abline(a=0, b= 1)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc  # very low


# Error Metric

conf.mat = table(test$Churned,fitted.class)
accuracy = sum(diag(conf.mat))/sum(conf.mat)
precision = conf.mat[2,2]/sum(conf.mat[,2])
recall = conf.mat[2,2]/sum(conf.mat[2,])

